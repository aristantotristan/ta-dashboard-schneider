/*
 * File: ESP32_Modbus_MQTT_18_SLAVES_v2.ino
 * Deskripsi: Mengirim data 18 SLAVE ID (001 s/d 018) ke HiveMQ Cloud.
 * Menggunakan Operation Time Register 2004 untuk akurasi OpH per meter.
 */

#include <WiFi.h>
#include <WiFiClientSecure.h>
#include <PubSubClient.h>
#include <ArduinoJson.h>
#include <ModbusMaster.h>
#include <Arduino.h> 
#include "time.h"

// --- KONFIGURASI WIFI & MQTT ---
const char* WIFI_SSID = "akg workshop";
const char* WIFI_PASS = ""; 
const char* MQTT_BROKER = "3367c11cb6104f8ea02e99014f2015ba.s1.eu.hivemq.cloud"; 
const int MQTT_PORT = 8883;
const char* MQTT_USER = "vercel_client"; 
const char* MQTT_PASS = "VercelPass123!"; 
const char* MQTT_TOPIC_DATA = "politeknik/meter/data";
const char* ntpServer = "pool.ntp.org";
const long gmtOffset_sec = 7 * 3600; 
const int daylightOffset_sec = 0;

// --- KONFIGURASI MODBUS ---
#define MAX485_DE_RE 4
#define RX2_PIN 16
#define TX2_PIN 17
#define MODBUS_BAUD 9600
const uint8_t START_ID = 1;
const uint8_t END_ID = 18; // SLAVE ID TERTINGGI
const long SCAN_INTERVAL = 15000; // 15 detik interval scan total

ModbusMaster node;
WiFiClientSecure espClient; 
PubSubClient mqttClient(espClient);
long lastScanTime = 0;

// --- MODBUS HELPER ---
void preTransmission() { digitalWrite(MAX485_DE_RE, HIGH); delayMicroseconds(50); }
void postTransmission() { delayMicroseconds(50); digitalWrite(MAX485_DE_RE, LOW); }

float readFloat(uint16_t addr) {
    uint8_t result = node.readHoldingRegisters(addr - 1, 2);
    if (result == node.ku8MBSuccess) {
        uint32_t raw = ((uint32_t)node.getResponseBuffer(0) << 16) | node.getResponseBuffer(1);
        float val; memcpy(&val, &raw, 4); return val;
    }
    return NAN;
}

double readEnergy(uint16_t addr) {
    uint8_t result = node.readHoldingRegisters(addr - 1, 4); 
    if (result == node.ku8MBSuccess) {
        uint64_t raw = ((uint64_t)node.getResponseBuffer(0) << 48) |
                       ((uint64_t)node.getResponseBuffer(1) << 32) |
                       ((uint64_t)node.getResponseBuffer(2) << 16) |
                       ((uint64_t)node.getResponseBuffer(3));
        return (double)raw / 1000.0; // kWh/kVARh
    }
    return NAN;
}

float readTime(uint16_t addr) {
    uint8_t result = node.readHoldingRegisters(addr - 1, 2);
    if (result == node.ku8MBSuccess) {
        uint32_t raw = ((uint32_t)node.getResponseBuffer(0) << 16) | node.getResponseBuffer(1);
        return (float)raw / 3600.0; // Hasil dalam Jam
    }
    return NAN;
}

// --------------------------------------------------
// --- FUNGSI KONEKSI WIFI & MQTT ---
// --------------------------------------------------
void setupWifi() {
    if (WiFi.status() == WL_CONNECTED) return;
    Serial.print("\nMenyambung ke WiFi: "); Serial.println(WIFI_SSID);
    WiFi.begin(WIFI_SSID, WIFI_PASS);
    
    int attempts = 0;
    while (WiFi.status() != WL_CONNECTED && attempts < 20) {
        delay(500); Serial.print("."); attempts++;
    }
    if (WiFi.status() == WL_CONNECTED) {
        Serial.println("\nWiFi Terhubung! IP: " + WiFi.localIP().toString());
        configTime(gmtOffset_sec, daylightOffset_sec, ntpServer);
        struct tm timeinfo;
        if(!getLocalTime(&timeinfo)){ Serial.println(" GAGAL sinkronisasi NTP!"); }
        else { Serial.println(" Waktu BERHASIL disinkronkan."); }
    } else {
        Serial.println("\nGagal terhubung WiFi.");
    }
}

void reconnectMqtt() {
    while (!mqttClient.connected()) {
        if (WiFi.status() != WL_CONNECTED) setupWifi(); 
        Serial.print("Menyambung ke HiveMQ (8883)...");
        String clientId = "ESP32-Master-" + String(random(0xffff), HEX);
        if (mqttClient.connect(clientId.c_str(), MQTT_USER, MQTT_PASS)) {
            Serial.println("BERHASIL! ðŸš€");
        } else {
            Serial.printf("GAGAL! rc=%d. Coba lagi 5s...\n", mqttClient.state());
            delay(5000);
        }
    }
}

// --------------------------------------------------
// --- FUNGSI UTAMA SCAN & PUBLISH ---
// --------------------------------------------------
void scanAndPublish() {
    Serial.printf("\n=== MULAI SIKLUS SCAN (ID %02d s/d %02d) ===\n", START_ID, END_ID);
    
    StaticJsonDocument<1200> doc; 
    char jsonBuffer[1200];

    // LOOPING DARI ID 1 SAMPAI 18
    for (uint8_t id = START_ID; id <= END_ID; id++) {
        node.begin(id, Serial2);
        delay(50);
        
        // Cek koneksi awal: Voltage (3020)
        float Volt = readFloat(3020); delay(30); 

        doc.clear();

        if (!isnan(Volt)) {
            // --- BACA SEMUA 12 PARAMETER ---
            float I1 = readFloat(3000); delay(30);
            float I2 = readFloat(3002); delay(30);
            float I3 = readFloat(3004); delay(30);
            float P = readFloat(3054); delay(30); 
            float Q = readFloat(3060); delay(30); 
            float S = readFloat(3068); delay(30); 
            float PF = readFloat(3084); delay(30);
            float Freq = readFloat(3110); delay(30);
            double E_Tot = readEnergy(3204); delay(30); 
            double Q_Tot = readEnergy(3220); delay(30); 
            double E_Part = readEnergy(3256); delay(30);
            double Q_Part = readEnergy(3272); delay(30);
            
            // PERUBAHAN KRUSIAL: Menggunakan Operation Time Register 2004
            float OpTime = readTime(2004); delay(30); 
            
            float P_display = isnan(P) ? 0.0 : P * 1000.0; 
            Serial.printf("âœ… [ID %02d] ONLINE! V: %.1f V. P: %.0f W\n", id, Volt, P_display);

            // --- BUILD JSON ---
            doc["id"] = id; 
            doc["status"] = "online";
            
            doc["EaT"] = isnan(E_Tot) ? 0.0 : round(E_Tot * 100.0) / 100.0;
            doc["ErT"] = isnan(Q_Tot) ? 0.0 : round(Q_Tot * 100.0) / 100.0;
            doc["EaP"] = isnan(E_Part) ? 0.0 : round(E_Part * 100.0) / 100.0;
            doc["ErP"] = isnan(Q_Part) ? 0.0 : round(Q_Part * 100.0) / 100.0;
            
            doc["V"] = isnan(Volt) ? 0.0 : round(Volt * 10.0) / 10.0;
            doc["I1"] = isnan(I1) ? 0.0 : round(I1 * 1000.0) / 1000.0;
            doc["I2"] = isnan(I2) ? 0.0 : round(I2 * 1000.0) / 1000.0;
            doc["I3"] = isnan(I3) ? 0.0 : round(I3 * 1000.0) / 1000.0;

            doc["P"] = isnan(P) ? 0.0 : (long)round(P * 1000.0); 
            doc["Q"] = isnan(Q) ? 0.0 : (long)round(Q * 1000.0); 
            doc["S"] = isnan(S) ? 0.0 : round(S * 100.0) / 100.0; 

            doc["PF"] = isnan(PF) ? 0.0 : round(PF * 1000.0) / 1000.0;
            doc["Hz"] = isnan(Freq) ? 0.0 : round(Freq * 10.0) / 10.0;
            doc["OpH"] = isnan(OpTime) ? 0.0 : round(OpTime * 10.0) / 10.0; 

        } else {
            // --- METER OFFLINE ---
            Serial.printf("âŒ [ID %02d] OFFLINE (Gagal baca 3020). Kirim status...\n", id);
            
            doc["id"] = id;
            doc["status"] = "offline"; 
        }
        
        // --- KIRIM KE MQTT ---
        serializeJson(doc, jsonBuffer);
        if (mqttClient.publish(MQTT_TOPIC_DATA, jsonBuffer)) {
             // Serial.printf("   -> [ID %02d] Sukses PUBLISH.\n", id);
        } else {
             Serial.printf("   -> âŒ [ID %02d] Gagal PUBLISH! RC: %d\n", id, mqttClient.state());
        }
        
        mqttClient.loop(); 
        delay(50); // Delay antar ID untuk stabilitas Modbus
    }
    Serial.println("=== SIKLUS SELESAI ===");
}

// --------------------------------------------------
// --- SETUP & LOOP ---
// --------------------------------------------------
void setup() {
    Serial.begin(115200);
    pinMode(MAX485_DE_RE, OUTPUT); 
    digitalWrite(MAX485_DE_RE, LOW);
    Serial2.begin(MODBUS_BAUD, SERIAL_8E1, RX2_PIN, TX2_PIN);
    
    node.preTransmission(preTransmission);
    node.postTransmission(postTransmission);
    
    Serial.println("\n--- ESP32 MODBUS to HIVEMQ (18 SLAVES) ---");
    setupWifi(); 
    
    espClient.setInsecure(); 
    
    mqttClient.setServer(MQTT_BROKER, MQTT_PORT);
    lastScanTime = millis() - SCAN_INTERVAL; 
}

void loop() {
    if (WiFi.status() != WL_CONNECTED) setupWifi();
    if (!mqttClient.connected()) reconnectMqtt();
    mqttClient.loop();
    
    if (millis() - lastScanTime > SCAN_INTERVAL) {
        scanAndPublish();
        lastScanTime = millis();
    }
}
